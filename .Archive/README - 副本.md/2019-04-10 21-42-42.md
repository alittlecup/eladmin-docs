
# 五、系统权限控制
本系统权限控制采用 ```RBAC```（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限，每一个角色拥有若干个菜单，这样，就构造成“用户-角色-权限”，“角色-菜单” 的授权模型。在这种模型中，用户与角色、角色与权限、角色与菜单之间构成了多对多的关系，如下图
![](https://i.loli.net/2019/03/28/5c9c93a520ab8.png)

## 5.1 后端权限控制
后端接口权限控制基于```Spring Security```（不清楚的可以自己去学习学习），因此每个请求都将携带```token```进行访问，当然可以过滤一些接口如：```Druid```监控，```swagger```文档，支付宝回调等。<br>配置文件位于：core -> config ->  WebSecurityConfig
``` java
// 关键代码
@Override
protected void configure(HttpSecurity httpSecurity) throws Exception {
    httpSecurity
            // 禁用 CSRF
            .csrf().disable()
            // 授权异常
            .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()
            // 不创建会话
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            .authorizeRequests()
            .antMatchers("/auth/**").permitAll()
            .antMatchers("/websocket/**").permitAll()
            .antMatchers("/druid/**").anonymous()
            // 支付宝回调
            .antMatchers("/api/aliPay/return").anonymous()
            .antMatchers("/api/aliPay/notify").anonymous()
            // swagger start
            .antMatchers("/swagger-ui.html").anonymous()
            .antMatchers("/swagger-resources/**").anonymous()
            .antMatchers("/webjars/**").anonymous()
            .antMatchers("/*/api-docs").anonymous()
            // swagger end
            .antMatchers("/test/**").anonymous()
            .antMatchers(HttpMethod.OPTIONS, "/**").anonymous()
            // 所有请求都需要认证
            .anyRequest().authenticated();
    httpSecurity
            .addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
}
```
### 5.1.1 数据交互
用户输入账号密码 -> 验证账号密码返回token -> 前端带上token请求数据 -> 后端返回数据<br>
数据交互流程如下图：
![](https://i.loli.net/2019/03/28/5c9c93b996ace.png)
### 5.1.2 接口权限控制
```Spring Security```允许我们在定义URL访问或方法访问所应有的权限时使用```Spring EL```表达式。<br>
如下表示用户拥有 ```ADMIN```、```MENU_ALL```、```MENU_EDIT``` 三个权限中的任意一个就能能访问```update```方法，但是如果方法前不加```@preAuthorize```注解，意味着所有用户都能访问update
``` java
@Log(description = "修改菜单")
@PutMapping(value = "/menus")
@PreAuthorize("hasAnyRole('ADMIN','MENU_ALL','MENU_EDIT')")
public ResponseEntity update(@Validated @RequestBody Menu resources){
    // 略
}
```
## 5.2 前端权限控制
前端页面的权限控制只需要引入权限判断函数，使用如下 ```v-if``` 去验证，用户没有该权限就不会显示该标签与该标签内的内容，具体代码如下：
``` html
<template>
  	<el-tab-pane v-if="checkPermission(['ADMIN'])" label="Admin">
		admin 权限的用户才能看到
	 </el-tab-pane>
</template>

<script>
import checkPermission from '@/utils/permission' // 权限判断函数

export default{
   methods: {
    checkPermission
   }
}
</script>
```
# 六、系统菜单路由
首先了解一些本项目配置路由时提供了哪些配置项。
```
//当设置 true 的时候该路由不会再侧边栏出现 如401，login等页面，或者如一些编辑页面/edit/1
hidden: true // (默认 false)

//当设置 noredirect 的时候该路由在面包屑导航中不可被点击
redirect: 'noredirect'

//当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式--如组件页面
//只有一个时，会将那个子路由当做根路由显示在侧边栏--如引导页面
//若你想不管路由下面的 children 声明的个数都显示你的根路由
//你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，一直显示根路由
alwaysShow: true

name: 'router-name' //设定路由的名字，一定要填写不然使用<keep-alive>时会出现各种问题
meta: {
  title: 'title' //设置该路由在侧边栏和面包屑中展示的名字
  icon: 'svg-name' //设置该路由的图标
  noCache: true //如果设置为true，则不会被 <keep-alive> 缓存(默认 false)
  breadcrumb: false // 如果设置为false，则不会在breadcrumb面包屑中显示
}
```	
示例：
```
{
  path: '/permission',
  component: Layout,
  redirect: '/permission/index', //重定向地址，在面包屑中点击会重定向去的地址
  hidden: true, // 不在侧边栏线上
  alwaysShow: true, //一直显示根路由
  children: [{
    path: 'index',
    component: ()=>import('@/views/permission/index'),
    name: 'permission',
    meta: {
      title: 'permission',
      icon: 'lock', //图标
      noCache: true // 不会被 <keep-alive> 缓存
    }
  }]
}
```
## 6.1 添加图标
如果你没有在本项目 Icon 中找到需要的图标，可以到 [iconfont.cn](iconfont.cn) 上选择并生成自己的业务图标库，再进行使用。或者其它 svg 图标网站，下载 svg 并放到 ```src/icons/svg``` 文件夹之中就可以了，下载方式如下图：

![](https://i.loli.net/2019/03/28/5c9c93ce6a575.gif)

使用方式：
```
<svg-icon icon-class="password" /> //icon-class 为 icon 的名字
```
## 6.2 添加菜单
本项目支持菜单动态路由，支持添加4级菜单，支持外链，支持自定义图标，通过选择角色，来控制菜单的渲染，这里演示动态添加菜单
### (1) 添加外链
![](https://i.loli.net/2019/03/28/5c9c93f3015a1.png)
### (2) 添加内部菜单
组件路径为 src/views

|   添加内部菜单  |   组件路径对应  |
|--- | --- |
|  ![](https://i.loli.net/2019/03/28/5c9c94097c0a2.png)   |  ![](https://i.loli.net/2019/03/28/5c9c941c788db.png)   |

### (3) 添加多级菜单
添加多级菜单请模仿项目内的多级菜单进行添加

![](https://i.loli.net/2019/03/28/5c9c9431cf379.png)

# 七、入门Spring Data Jpa
Jpa（java Persistence API，java持久化 api），它定义了对象关系映射（ORM）以及实体对象持久化的标准接口。在Spring boot中JPA是依靠Hibernate才得以实现对的，JPA可使开发者用极简的代码实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！
关于Jpa的使用，我写了两篇文章，供大家学习：
## 7.1 Jpa简单入门
文档地址： [https://blog.csdn.net/zj7321/article/details/82995928](https://blog.csdn.net/zj7321/article/details/82995928)
## 7.2 Jpa高级查询
文档地址： [https://blog.csdn.net/zj7321/article/details/83067976](https://blog.csdn.net/zj7321/article/details/83067976)

# 八、缓存的使用
本系统集成了redis缓存，使用注解就能对系统缓存进行操作，并且提供了可视化的redis缓存操作与查看
## 8.1 配置缓存
redis序列化时可能会报错：<p style="color:red">com.alibaba.fastjson.JSONException: autoType is not support</p> 
错误发生的原因是：```redis```序列化时将```class```信息写入，反序列化的时候，```fastjson```默认情况下会开启```autoType```的检查，相当于一个白名单检查，如果序列化信息中的类路径不在```autoType```中，这个时候就会抛出上面的异常

**解决办法：**

1、全局开启AutoType，不建议使用
<p style="color:#e96900">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</p>
2、建议小范围指定白名单
<p style="color:#e96900">ParserConfig.getGlobalInstance().addAccept("me.zhengjie.system.domain");</p>

**完整配置如下**
``` java
/**
 * @author jie
 * @date 2018-11-24
 */
@Slf4j
@Configuration
@EnableCaching
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
public class RedisConfig extends CachingConfigurerSupport {

    @Value("${spring.redis.host}")
    private String host;

    @Value("${spring.redis.port}")
    private int port;

    @Value("${spring.redis.timeout}")
    private int timeout;

    @Value("${spring.redis.jedis.pool.max-idle}")
    private int maxIdle;

    @Value("${spring.redis.jedis.pool.max-wait}")
    private long maxWaitMillis;

    @Value("${spring.redis.password}")
    private String password;

    /**
     * 配置 redis 连接池
     * @return
     */
    @Bean
    public JedisPool redisPoolFactory(){
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxIdle(maxIdle);
        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);
        if (StrUtil.isNotBlank(password)) {
            return new JedisPool(jedisPoolConfig, host, port, timeout, password);
        } else {
            return new JedisPool(jedisPoolConfig, host, port,timeout);
        }
    }

    /**
     *  设置 redis 数据默认过期时间
     *  设置@cacheable 序列化方式
     * @return
     */
    @Bean
    public RedisCacheConfiguration redisCacheConfiguration(){
        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);
        RedisCacheConfiguration configuration = RedisCacheConfiguration.defaultCacheConfig();
        configuration = configuration.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(fastJsonRedisSerializer)).entryTtl(Duration.ofHours(2));
        return configuration;
    }

    @Bean(name = "redisTemplate")
    @ConditionalOnMissingBean(name = "redisTemplate")
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object, Object> template = new RedisTemplate<>();
        //序列化
        FastJsonRedisSerializer fastJsonRedisSerializer = new FastJsonRedisSerializer(Object.class);
        // value值的序列化采用fastJsonRedisSerializer
        template.setValueSerializer(fastJsonRedisSerializer);
        template.setHashValueSerializer(fastJsonRedisSerializer);
        // 全局开启AutoType，不建议使用
        // ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        // 建议使用这种方式，小范围指定白名单
        ParserConfig.getGlobalInstance().addAccept("me.zhengjie.system.service.dto");
        ParserConfig.getGlobalInstance().addAccept("me.zhengjie.system.domain");
        ParserConfig.getGlobalInstance().addAccept("me.zhengjie.tools.domain");
        ParserConfig.getGlobalInstance().addAccept("me.zhengjie.quartz.domain");
        // key的序列化采用StringRedisSerializer
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }

    /**
     * 自定义缓存key生成策略
     * 使用方法 @Cacheable(keyGenerator="keyGenerator")
     * @return
     */
    @Bean
    @Override
    public KeyGenerator keyGenerator() {
        return (target, method, params) -> {
            StringBuilder sb = new StringBuilder();
            sb.append(target.getClass().getName());
            sb.append(method.getName());
            for (Object obj : params) {
                sb.append(obj.toString());
            }
            log.info(sb.toString());
            return sb.toString();
        };
    }
}
```
## 8.2 具体使用

```@CacheConfig``` 一般用于Service类上
```@Cacheable``` 用于Service方法上
```@CachePut``` 用于更新缓存
```@CacheEvict``` 用于清除缓存

使用自定义缓存key生成策略，```@Cacheable(keyGenerator="keyGenerator")``` 具体使用如下
``` java
@CacheConfig(cacheNames = "qiNiu")
public interface QiNiuService {

    /**
     * 查配置
     * @return
     */
    @Cacheable(key = "'1'")
    QiniuConfig find();

    /**
     * 修改配置
     * @param qiniuConfig
     * @return
     */
    @CachePut(key = "'1'")
    QiniuConfig update(QiniuConfig qiniuConfig);

    /**
     * 查询文件
     * @param id
     * @return
     */
    @Cacheable(keyGenerator = "keyGenerator")
    QiniuContent findByContentId(Long id);

    /**
     * 删除文件
     * @param content
     * @param config
     * @return
     */
    @CacheEvict(allEntries = true)
    void delete(QiniuContent content, QiniuConfig config);
}
```
## 8.3 可视化redis操作

![](https://i.loli.net/2019/03/28/5c9c9445b982b.png)

# 九、异常处理机制

## 9.1 后端异常处理
本系统封装了一些常用的异常处理类，并使用GlobalExceptionHandler类对异常进行统一处理，使用异常处理模块如下图：

![](https://i.loli.net/2019/03/28/5c9c945e998bc.png)

## 9.2 前端异常处理
在前端的 ```src/utils/request.js``` 文件中对所有的```request```请求进行拦截，通过 ```response``` 拦截器对接口返回的状态码进行分析与异常拦截
``` html
// response 拦截器
service.interceptors.response.use(
  response => {
    const code = response.status
    if (code < 200 || code > 300) {
      Notification.error({
        title: response.message
      })
      return Promise.reject('error')
    } else {
      return response.data
    }
  },
  error => {
    let code = 0
    try {
      code = error.response.data.status
    } catch (e) {
      if (error.toString().indexOf('timeout')) {
        Notification.error({
          title: '请求超时',
          duration: 2500
        })
        return Promise.reject(error)
      }
    }
    if (code === 401) {
      MessageBox.confirm(
        '登录状态已失效，你可以取消继续留在该页面，或者重新登录',
        '提示',
        {
          confirmButtonText: '重新登录',
          cancelButtonText: '取消',
          type: 'warning'
        }
      ).then(() => {
        store.dispatch('LogOut').then(() => {
          location.reload() // 为了重新实例化vue-router对象 避免bug
        })
      })
    } else if (code === 403) {
      router.push({ path: '/401' })
    } else {
      const errorMsg = error.response.data.message
      if (errorMsg !== undefined) {
        Notification.error({
          title: errorMsg,
          duration: 2500
        })
      }
    }
    return Promise.reject(error)
  }
)
```

# 十、系统工具类
系统常用工具类位于 eladmin-common 模块中的 utils 包下，具体作用如下：

## 10.1 ElAdminConstant
此工具类用户记录系统常用的静态常量
## 10.2 EncryptUtils
提供：Md5加密，对称加密，对称解密
## 10.3 FileUtil
```FileUtil``` 继承了 ```hutool```工具包中的 [FileUtil](http://hutool.mydoc.io/#text_319390)，并对其进行扩展，新增功能如下：
1. MultipartFile转File：	```toFile```
2. 获取文件扩展名：```getExtensionName```
3. 获取不带扩展名的文件名：```getFileNameNoEx```
4. 删除文件：```deleteFile```
5. 获取文件大小：```getSize```

## 10.4 ListSortUtil
List按照指定字段排序的工具类
## 10.5 PageUtil
系统分页工具类，对返回的数据进行处理
## 10.6 RequestHolder
随时获取 ```HttpServletRequest```
## 10.7 SecurityContextHolder（获取当前登录用户）
通过此工具类，可以直接获取当前登录的用户
## 10.8 SpringContextHolder
随时获取 ```spring bean```
## 10.9 StringUtils
```StringUtils``` 继承了 ```apache```工具包中的 ```StringUtils```，并对其进行扩展，新增功能如下：
1. 是否包含字符串：```inString```
2. 驼峰命名法工具：```toCamelCase、toCapitalizeCamelCase、toUnderScoreCase```具体查看源码
3. 获取ip地址：```getIP```
4. 获取当天是周几：```getWeekDay```

## 10.10 ThrowableUtil
异常工具，可获取异常堆栈信息

# 十一、代码生成功能
本系统提供高灵活度的代码生成功能，只需要在数据库中设计好表结构，就能一键生成前后端代码，是不是很nice，具体使用说明如下：

## 11.1 设计表结构
这一步很关键，也有需要注意的地方：
1. 特别注意、```主键需要设计成自增```
2. 设计字段是否为空
3. 设计注释，```前端会根据注释生成表格标题```

![](https://i.loli.net/2019/03/28/5c9c94747b040.png)

## 11.2 界面预览
我们数据库中表都能在这看到，并且根据自己的需要进行 ```生成器配置```

![](https://i.loli.net/2019/03/28/5c9c949238a5b.png)

## 11.3 生成器配置
命名有些```中二```，但是不影响他的实用性，相关说明如下

![](https://i.loli.net/2019/03/28/5c9c94a5899a2.png)

1. 至于包下：这个的意思是```生成的代码放到哪个包里面```
2. 模块名称：这个顾名思义就是模块的名称
3. 前端路径：前端代码生成的路径
4. API路径：这个默认至于 ```src/api``` 目录下
5. 是否覆盖：危险操作，需谨慎

## 11.4 代码生成
配置好生成器后就能进行代码生成啦，具体操作如下：
1. 点击生成代码按钮
2. 可以临时修改字段标题
3. 配置查询方式，可选：精确或者模糊
4. 列表显示：前端页面是否显示该字段，建议不要显示```ID```
5. 当然是点击生成按钮啦

![](https://i.loli.net/2019/03/28/5c9c94b9a8989.png)
## 11.5 额外的工作
代码生成可以节省你百分之```75```以上的开发任务，部分是需要自己需求进行修改的，如：
1. 添加菜单：虽然代码给你生成了，但是菜单还是需要自己手动添加的
2. 表单验证：前端代码没有表单验证，这个需要自己修改

## 11.6 预览
添加菜单后，生成的界面如下：<br>
1、搜索

![](https://i.loli.net/2019/03/28/5c9c94cec325d.png)

2、新增

![](https://i.loli.net/2019/03/28/5c9c94e967d00.png)

3、列表

![](https://i.loli.net/2019/03/28/5c9c94fd8d347.png)

# 十二、版本更新说明
## 2018年12月23日（v1.0）
这个版本是一个纯净的后台，当然也有挺多的bug
- 主要框架：spring boot+Spring Security+Redis
- 密码加密：采用MD5加盐加密
- 系统日志：使用aop保存操作日志
- 实体映射：使用MapStruct
- 前端菜单：支持动态路由

## 2018年12月25号（v1.1）
发布了第二个版本，也修复了v1.0中已知的bug

**新增功能**
-  实时控制台

**Bug修复**
-  修复菜单渲染根据soft字段排序
-  修复菜单部分字段不更新的bug
-  修复前端菜单面包屑导航点击无页面的bug

**细节优化**
-  优化站点统计，改为定时器方式每日0点重置站点访客信息
-  优化默认用户、角色、权限不可删除和修改

## 2018年12月28号（v1.2）
**新增**
- 邮箱工具
- SM.MS免费图床
- 富文本编辑器

**优化**
- 查询细节优化
- 后台接口权限细节优化
- 前端新增和修改按钮loading
- 前端请求超时异常处理
- 菜单sort字段拼写错误，由soft更正为sort
- 前端图标选择组件优化，加入滚动条
- 常用接口处理，前端将图片上传接口和实时控制台接口存入store->modules->api.js

**bug修复**
- 一级菜单无法渲染（后端）
- 修复用户存在多个角色时菜单获取失败（后端）
- 修复角色管理前缀为ROLE_，与spring security的默认前端冲突，导致无权限访问，解决办法：将角色管理的前缀改为ROLES_

## 2018年12月31号（v1.3）
**新增**
- 个人中心上线，修改密码功能，根据邮箱验证码修改邮箱功能，修改头像功能
- 七牛云存储
- 支付宝支付

**优化**
- 实时控制台异常堆栈信息打印
- 对403错误和401错误分开处理

## 2019年1月8号（v1.4）
该版本优化了前端，让form组件可以复用，为下个版本的代码生成做准备
**新增**
-  定时任务管理 整合quartz做定时任务

**调整与优化**
- 前端页面优化，表单组件复用
- 调整redis过期时间为2小时

**bug修复**
- 修复redis key过长时删除失败的问题
- 修复多级菜单渲染异常问题